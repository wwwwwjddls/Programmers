[문제 설명]
Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.
Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.
Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.

[제한 사항]
• 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.
• 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.
• 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.

[입출력 예]
brown / yellow / return
10 / 2 / [4, 3]
8 / 1 / [3, 3]
24 / 24 / [8, 6]

[풀이]
1. 완전탐색
2. brown과 yellow를 더해서 총 격자 수를 board에 담는다.
3. 두 수의 곱이 yellow가 되는 경우의 수를 구한다.
4. 각 두 수+2(brown테두리를 더한 수)의 곱이 board가 되는 수를 구한다.
5. 큰 수+2를 answer의 첫 번째에 담고, 작은 수+2를 answer의 두 번째 담는다.

[소스 - JavaScript]
function solution(brown, yellow) {
  var answer = [];
  var board  = brown+yellow;
	
  Loop1 : for(var i=1; i<=yellow; i++) {
    for(var j=yellow; j>0; j--) {
      if(i*j == yellow && (i+2)*(j+2) == board) {
        answer = [j+2, i+2];
        break Loop1;
      } 
    }
  }

  return answer;
}

[소스 - Java]
class Solution {
  public int[] solution(int brown, int yellow) {
    int[] answer = new int[2];
    int board    = brown+yellow;
		
    Loop1: for(int i=1; i<=yellow; i++) {
      for(int j=yellow; j>0; j--) {
        if(i*j == yellow && (i+2)*(j+2) == board) {
          answer[0] = j+2;
          answer[1] = i+2;
          break Loop1;
        }
      }
    }
				
    return answer;
  }
}
